{"version":3,"sources":["../../src/datasource-zabbix/zabbixDBConnector.js"],"names":["ZabbixDBConnectorFactory","datasourceSrv","backendSrv","ZabbixDBConnector","sqlDataSourceId","options","limit","DEFAULT_QUERY_LIMIT","datasourceId","ds","_","find","getAll","loadDatasource","name","then","console","log","Promise","reject","testQuery","invokeSQLQuery","items","timeFrom","timeTill","intervalMs","consolidateBy","intervalSec","Math","ceil","aggFunction","consolidateByFunc","grouped_items","groupBy","promises","map","value_type","itemids","join","table","HISTORY_TO_TABLE_MAP","query","compactSQLQuery","all","flatten","results","TREND_TO_TABLE_MAP","valueColumn","includes","consolidateByTrendColumns","history","addHostName","convertGrafanaTSResponse","queryDef","refId","format","rawSql","maxDataPoints","datasourceRequest","url","method","data","queries","response","series","time_series","hosts","uniqBy","grafanaSeries","itemid","item","alias","keys","length","host","hostid","datapoints","cloneDeep","points","target","sortBy","replace","angular","module","factory"],"mappings":"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","file":"zabbixDBConnector.js","sourcesContent":["import angular from 'angular';\r\nimport _ from 'lodash';\r\n\r\nconst DEFAULT_QUERY_LIMIT = 10000;\r\nconst HISTORY_TO_TABLE_MAP = {\r\n  '0': 'history',\r\n  '1': 'history_str',\r\n  '2': 'history_log',\r\n  '3': 'history_uint',\r\n  '4': 'history_text'\r\n};\r\n\r\nconst TREND_TO_TABLE_MAP = {\r\n  '0': 'trends',\r\n  '3': 'trends_uint'\r\n};\r\n\r\nconst consolidateByFunc = {\r\n  'avg': 'AVG',\r\n  'min': 'MIN',\r\n  'max': 'MAX',\r\n  'sum': 'SUM',\r\n  'count': 'COUNT'\r\n};\r\n\r\nconst consolidateByTrendColumns = {\r\n  'avg': 'value_avg',\r\n  'min': 'value_min',\r\n  'max': 'value_max'\r\n};\r\n\r\n/** @ngInject */\r\nfunction ZabbixDBConnectorFactory(datasourceSrv, backendSrv) {\r\n\r\n  class ZabbixDBConnector {\r\n\r\n    constructor(sqlDataSourceId, options = {}) {\r\n      let {limit} = options;\r\n\r\n      this.sqlDataSourceId = sqlDataSourceId;\r\n      this.limit = limit || DEFAULT_QUERY_LIMIT;\r\n    }\r\n\r\n    /**\r\n     * Try to load DS with given id to check it's exist.\r\n     * @param {*} datasourceId ID of SQL data source\r\n     */\r\n    loadSQLDataSource(datasourceId) {\r\n      let ds = _.find(datasourceSrv.getAll(), {'id': datasourceId});\r\n      if (ds) {\r\n        return datasourceSrv.loadDatasource(ds.name)\r\n        .then(ds => {\r\n          console.log('SQL data source loaded', ds);\r\n        });\r\n      } else {\r\n        return Promise.reject(`SQL Data Source with ID ${datasourceId} not found`);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Try to invoke test query for one of Zabbix database tables.\r\n     */\r\n    testSQLDataSource() {\r\n      let testQuery = `SELECT itemid AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\r\n      return this.invokeSQLQuery(testQuery);\r\n    }\r\n\r\n    getHistory(items, timeFrom, timeTill, options) {\r\n      let {intervalMs, consolidateBy} = options;\r\n      let intervalSec = Math.ceil(intervalMs / 1000);\r\n\r\n      consolidateBy = consolidateBy || 'avg';\r\n      let aggFunction = consolidateByFunc[consolidateBy];\r\n\r\n      // Group items by value type and perform request for each value type\r\n      let grouped_items = _.groupBy(items, 'value_type');\r\n      let promises = _.map(grouped_items, (items, value_type) => {\r\n        let itemids = _.map(items, 'itemid').join(', ');\r\n        let table = HISTORY_TO_TABLE_MAP[value_type];\r\n\r\n        let query = `\r\n          SELECT itemid AS metric, clock AS time_sec, ${aggFunction}(value) AS value\r\n            FROM ${table}\r\n            WHERE itemid IN (${itemids})\r\n              AND clock > ${timeFrom} AND clock < ${timeTill}\r\n            GROUP BY time_sec DIV ${intervalSec}, metric\r\n        `;\r\n\r\n        query = compactSQLQuery(query);\r\n        return this.invokeSQLQuery(query);\r\n      });\r\n\r\n      return Promise.all(promises).then(results => {\r\n        return _.flatten(results);\r\n      });\r\n    }\r\n\r\n    getTrends(items, timeFrom, timeTill, options) {\r\n      let {intervalMs, consolidateBy} = options;\r\n      let intervalSec = Math.ceil(intervalMs / 1000);\r\n\r\n      consolidateBy = consolidateBy || 'avg';\r\n      let aggFunction = consolidateByFunc[consolidateBy];\r\n\r\n      // Group items by value type and perform request for each value type\r\n      let grouped_items = _.groupBy(items, 'value_type');\r\n      let promises = _.map(grouped_items, (items, value_type) => {\r\n        let itemids = _.map(items, 'itemid').join(', ');\r\n        let table = TREND_TO_TABLE_MAP[value_type];\r\n        let valueColumn = _.includes(['avg', 'min', 'max'], consolidateBy) ? consolidateBy : 'avg';\r\n        valueColumn = consolidateByTrendColumns[valueColumn];\r\n\r\n        let query = `\r\n          SELECT itemid AS metric, clock AS time_sec, ${aggFunction}(${valueColumn}) AS value\r\n            FROM ${table}\r\n            WHERE itemid IN (${itemids})\r\n              AND clock > ${timeFrom} AND clock < ${timeTill}\r\n            GROUP BY time_sec DIV ${intervalSec}, metric\r\n        `;\r\n\r\n        query = compactSQLQuery(query);\r\n        return this.invokeSQLQuery(query);\r\n      });\r\n\r\n      return Promise.all(promises).then(results => {\r\n        return _.flatten(results);\r\n      });\r\n    }\r\n\r\n    handleGrafanaTSResponse(history, items, addHostName = true) {\r\n      return convertGrafanaTSResponse(history, items, addHostName);\r\n    }\r\n\r\n    invokeSQLQuery(query) {\r\n      let queryDef = {\r\n        refId: 'A',\r\n        format: 'time_series',\r\n        datasourceId: this.sqlDataSourceId,\r\n        rawSql: query,\r\n        maxDataPoints: this.limit\r\n      };\r\n\r\n      return backendSrv.datasourceRequest({\r\n        url: '/api/tsdb/query',\r\n        method: 'POST',\r\n        data: {\r\n          queries: [queryDef],\r\n        }\r\n      })\r\n      .then(response => {\r\n        let results = response.data.results;\r\n        if (results['A']) {\r\n          return results['A'].series;\r\n        } else {\r\n          return null;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  return ZabbixDBConnector;\r\n}\r\n\r\nangular\r\n  .module('grafana.services')\r\n  .factory('ZabbixDBConnector', ZabbixDBConnectorFactory);\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\r\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid'); //uniqBy is needed to deduplicate\r\n  let grafanaSeries = _.map(time_series, series => {\r\n    let itemid = series.name;\r\n    var item = _.find(items, {'itemid': itemid});\r\n    var alias = item.name;\r\n    if (_.keys(hosts).length > 1 && addHostName) { //only when actual multi hosts selected\r\n      var host = _.find(hosts, {'hostid': item.hostid});\r\n      alias = host.name + \": \" + alias;\r\n    }\r\n    // zabbixCachingProxy deduplicates requests and returns one time series for equal queries.\r\n    // Clone is needed to prevent changing of series object shared between all targets.\r\n    let datapoints = _.cloneDeep(series.points);\r\n    return {\r\n      target: alias,\r\n      datapoints: datapoints\r\n    };\r\n  });\r\n\r\n  return _.sortBy(grafanaSeries, 'target');\r\n}\r\n\r\nfunction compactSQLQuery(query) {\r\n  return query.replace(/\\s+/g, ' ');\r\n}\r\n"]}